{
  "name": "command",
  "displayName": "Command",
  "description": "The Pulumi Command Provider enables you to execute commands and scripts either locally or remotely as part of the Pulumi resource model.",
  "keywords": [
    "pulumi",
    "command",
    "category/utility",
    "kind/native"
  ],
  "homepage": "https://pulumi.com",
  "license": "Apache-2.0",
  "repository": "https://github.com/pulumi/pulumi-command",
  "logoUrl": "https://raw.githubusercontent.com/pulumi/pulumi-command/master/assets/logo.svg",
  "publisher": "Pulumi",
  "meta": {
    "moduleFormat": "(.*)"
  },
  "language": {
    "csharp": {
      "packageReferences": {
        "Pulumi": "3.*"
      },
      "respectSchemaVersion": true
    },
    "go": {
      "generateResourceContainerTypes": true,
      "importBasePath": "github.com/pulumi/pulumi-command/sdk/go/command",
      "respectSchemaVersion": true
    },
    "java": {
      "buildFiles": "gradle",
      "dependencies": {
        "com.google.code.findbugs:jsr305": "3.0.2",
        "com.google.code.gson:gson": "2.8.9",
        "com.pulumi:pulumi": "0.10.0"
      },
      "gradleNexusPublishPluginVersion": "1.1.0"
    },
    "nodejs": {
      "dependencies": {
        "@pulumi/pulumi": "^3.0.0"
      },
      "respectSchemaVersion": true
    },
    "python": {
      "pyproject": {
        "enabled": true
      },
      "requires": {
        "pulumi": ">=3.0.0,<4.0.0"
      },
      "respectSchemaVersion": true
    }
  },
  "config": {},
  "types": {
    "command:local:Logging": {
      "type": "string",
      "enum": [
        {
          "description": "Capture stdout in logs but not stderr",
          "value": "stdout"
        },
        {
          "description": "Capture stderr in logs but not stdout",
          "value": "stderr"
        },
        {
          "description": "Capture stdout and stderr in logs",
          "value": "stdoutAndStderr"
        },
        {
          "description": "Capture no logs",
          "value": "none"
        }
      ]
    },
    "command:remote:Connection": {
      "description": "Instructions for how to connect to a remote endpoint.",
      "properties": {
        "agentSocketPath": {
          "type": "string",
          "description": "SSH Agent socket path. Default to environment variable SSH_AUTH_SOCK if present."
        },
        "dialErrorLimit": {
          "type": "integer",
          "description": "Max allowed errors on trying to dial the remote host. -1 set count to unlimited. Default value is 10.",
          "default": 10
        },
        "host": {
          "type": "string",
          "description": "The address of the resource to connect to."
        },
        "password": {
          "type": "string",
          "description": "The password we should use for the connection."
        },
        "perDialTimeout": {
          "type": "integer",
          "description": "Max number of seconds for each dial attempt. 0 implies no maximum. Default value is 15 seconds.",
          "default": 15
        },
        "port": {
          "type": "number",
          "description": "The port to connect to. Defaults to 22.",
          "default": 22
        },
        "privateKey": {
          "type": "string",
          "description": "The contents of an SSH key to use for the connection. This takes preference over the password if provided."
        },
        "privateKeyPassword": {
          "type": "string",
          "description": "The password to use in case the private key is encrypted."
        },
        "proxy": {
          "$ref": "#/types/command:remote:ProxyConnection",
          "description": "The connection settings for the bastion/proxy host."
        },
        "user": {
          "type": "string",
          "description": "The user that we should use for the connection.",
          "default": "root"
        }
      },
      "type": "object",
      "required": [
        "host"
      ]
    },
    "command:remote:Logging": {
      "type": "string",
      "enum": [
        {
          "description": "Capture stdout in logs but not stderr",
          "value": "stdout"
        },
        {
          "description": "Capture stderr in logs but not stdout",
          "value": "stderr"
        },
        {
          "description": "Capture stdout and stderr in logs",
          "value": "stdoutAndStderr"
        },
        {
          "description": "Capture no logs",
          "value": "none"
        }
      ]
    },
    "command:remote:ProxyConnection": {
      "description": "Instructions for how to connect to a remote endpoint via a bastion host.",
      "properties": {
        "agentSocketPath": {
          "type": "string",
          "description": "SSH Agent socket path. Default to environment variable SSH_AUTH_SOCK if present."
        },
        "dialErrorLimit": {
          "type": "integer",
          "description": "Max allowed errors on trying to dial the remote host. -1 set count to unlimited. Default value is 10.",
          "default": 10
        },
        "host": {
          "type": "string",
          "description": "The address of the bastion host to connect to."
        },
        "password": {
          "type": "string",
          "description": "The password we should use for the connection to the bastion host."
        },
        "perDialTimeout": {
          "type": "integer",
          "description": "Max number of seconds for each dial attempt. 0 implies no maximum. Default value is 15 seconds.",
          "default": 15
        },
        "port": {
          "type": "number",
          "description": "The port of the bastion host to connect to.",
          "default": 22
        },
        "privateKey": {
          "type": "string",
          "description": "The contents of an SSH key to use for the connection. This takes preference over the password if provided."
        },
        "privateKeyPassword": {
          "type": "string",
          "description": "The password to use in case the private key is encrypted."
        },
        "user": {
          "type": "string",
          "description": "The user that we should use for the connection to the bastion host.",
          "default": "root"
        }
      },
      "type": "object",
      "required": [
        "host"
      ]
    }
  },
  "provider": {
    "type": "object"
  },
  "resources": {
    "command:local:Command": {
      "description": "A local command to be executed.\n\nThis command can be inserted into the life cycles of other resources using the `dependsOn` or `parent` resource options. A command is considered to have failed when it finished with a non-zero exit code. This will fail the CRUD step of the `Command` resource.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Triggers\n\nThis example defines several trigger values of various kinds. Changes to any of them will cause `cmd` to be re-run.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as command from \"@pulumi/command\";\nimport * as random from \"@pulumi/random\";\n\nconst str = \"foo\";\nconst fileAsset = new pulumi.asset.FileAsset(\"Pulumi.yaml\");\nconst rand = new random.RandomString(\"rand\", {length: 5});\nconst localFile = new command.local.Command(\"localFile\", {\n    create: \"touch foo.txt\",\n    archivePaths: [\"*.txt\"],\n});\n\nconst cmd = new command.local.Command(\"cmd\", {\n    create: \"echo create > op.txt\",\n    delete: \"echo delete >> op.txt\",\n    triggers: [\n        str,\n        rand.result,\n        fileAsset,\n        localFile.archive,\n    ],\n});\n```\n\n```python\nimport pulumi\nimport pulumi_command as command\nimport pulumi_random as random\n\nfoo = \"foo\"\nfile_asset_var = pulumi.FileAsset(\"Pulumi.yaml\")\nrand = random.RandomString(\"rand\", length=5)\nlocal_file = command.local.Command(\"localFile\",\n    create=\"touch foo.txt\",\n    archive_paths=[\"*.txt\"])\n\ncmd = command.local.Command(\"cmd\",\n    create=\"echo create > op.txt\",\n    delete=\"echo delete >> op.txt\",\n    triggers=[\n        foo,\n        rand.result,\n        file_asset_var,\n        local_file.archive,\n    ])\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-command/sdk/go/command/local\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstr := pulumi.String(\"foo\")\n\n\t\tfileAsset := pulumi.NewFileAsset(\"Pulumi.yaml\")\n\n\t\trand, err := random.NewRandomString(ctx, \"rand\", &random.RandomStringArgs{\n\t\t\tLength: pulumi.Int(5),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlocalFile, err := local.NewCommand(ctx, \"localFile\", &local.CommandArgs{\n\t\t\tCreate: pulumi.String(\"touch foo.txt\"),\n\t\t\tArchivePaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*.txt\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = local.NewCommand(ctx, \"cmd\", &local.CommandArgs{\n\t\t\tCreate: pulumi.String(\"echo create > op.txt\"),\n\t\t\tDelete: pulumi.String(\"echo delete >> op.txt\"),\n\t\t\tTriggers: pulumi.Array{\n\t\t\t\tstr,\n\t\t\t\trand.Result,\n\t\t\t\tfileAsset,\n\t\t\t\tlocalFile.Archive,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```csharp\nusing Pulumi;\nusing Command = Pulumi.Command;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =>\n{\n    var str = \"foo\";\n\n    var fileAssetVar = new FileAsset(\"Pulumi.yaml\");\n\n    var rand = new Random.RandomString(\"rand\", new()\n    {\n        Length = 5,\n    });\n\n    var localFile = new Command.Local.Command(\"localFile\", new()\n    {\n        Create = \"touch foo.txt\",\n        ArchivePaths = new[]\n        {\n            \"*.txt\",\n        },\n    });\n\n    var cmd = new Command.Local.Command(\"cmd\", new()\n    {\n        Create = \"echo create > op.txt\",\n        Delete = \"echo delete >> op.txt\",\n        Triggers = new object[]\n        {\n            str,\n            rand.Result,\n            fileAssetVar,\n            localFile.Archive,\n        },\n    });\n\n});\n```\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fileAssetVar = new FileAsset(\"Pulumi.yaml\");\n\n        var rand = new RandomString(\"rand\", RandomStringArgs.builder()\n            .length(5)\n            .build());\n\n        var localFile = new Command(\"localFile\", CommandArgs.builder()\n            .create(\"touch foo.txt\")\n            .archivePaths(\"*.txt\")\n            .build());\n\n        var cmd = new Command(\"cmd\", CommandArgs.builder()\n            .create(\"echo create > op.txt\")\n            .delete(\"echo delete >> op.txt\")\n            .triggers(\n                rand.result(),\n                fileAssetVar,\n                localFile.archive())\n            .build());\n\n    }\n}\n```\n\n```yaml\nconfig: {}\noutputs: {}\nresources:\n  rand:\n    type: random:index/randomString:RandomString\n    properties:\n      length: 5\n\n  localFile:\n    type: command:local:Command\n    properties:\n      create: touch foo.txt\n      archivePaths:\n        - \"*.txt\"\n\n  cmd:\n    type: command:local:Command\n    properties:\n      create: echo create > op.txt\n      delete: echo delete >> op.txt\n      triggers:\n        - ${rand.result}\n        - ${fileAsset}\n        - ${localFile.archive}\n\nvariables:\n  fileAsset:\n    fn::fileAsset: \"Pulumi.yaml\"\n```\n{{% /example %}}\n\n{{% /examples %}}",
      "properties": {
        "addPreviousOutputInEnv": {
          "type": "boolean",
          "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
          "default": true
        },
        "archive": {
          "$ref": "pulumi.json#/Archive",
          "description": "An archive asset containing files found after running the command."
        },
        "archivePaths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of path globs to return as a single archive asset after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
        },
        "assetPaths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of path globs to read after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
        },
        "assets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Asset"
          },
          "description": "A map of assets found after running the command.\nThe key is the relative path from the command dir"
        },
        "create": {
          "type": "string",
          "description": "The command to run on create."
        },
        "delete": {
          "type": "string",
          "description": "The command to run on delete. The environment variables PULUMI_COMMAND_STDOUT\nand PULUMI_COMMAND_STDERR are set to the stdout and stderr properties of the\nCommand resource from previous create or update steps."
        },
        "dir": {
          "type": "string",
          "description": "The directory from which to run the command from. If `dir` does not exist, then\n`Command` will fail."
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional environment variables available to the command's process."
        },
        "interpreter": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The program and arguments to run the command.\nOn Linux and macOS, defaults to: `[\"/bin/sh\", \"-c\"]`. On Windows, defaults to: `[\"cmd\", \"/C\"]`"
        },
        "logging": {
          "$ref": "#/types/command:local:Logging",
          "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
        },
        "stderr": {
          "type": "string",
          "description": "The standard error of the command's process"
        },
        "stdin": {
          "type": "string",
          "description": "Pass a string to the command's process as standard in"
        },
        "stdout": {
          "type": "string",
          "description": "The standard output of the command's process"
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger a resource replacement on changes to any of these values. The\ntrigger values can be of any type. If a value is different in the current update compared to the\nprevious update, the resource will be replaced, i.e., the \"create\" command will be re-run.\nPlease see the resource documentation for examples.",
          "replaceOnChanges": true
        },
        "update": {
          "type": "string",
          "description": "The command to run on update, if empty, create will \nrun again. The environment variables PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR \nare set to the stdout and stderr properties of the Command resource from previous \ncreate or update steps."
        }
      },
      "type": "object",
      "required": [
        "stderr",
        "stdout"
      ],
      "inputProperties": {
        "addPreviousOutputInEnv": {
          "type": "boolean",
          "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
          "default": true
        },
        "archivePaths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of path globs to return as a single archive asset after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
        },
        "assetPaths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of path globs to read after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
        },
        "create": {
          "type": "string",
          "description": "The command to run on create."
        },
        "delete": {
          "type": "string",
          "description": "The command to run on delete. The environment variables PULUMI_COMMAND_STDOUT\nand PULUMI_COMMAND_STDERR are set to the stdout and stderr properties of the\nCommand resource from previous create or update steps."
        },
        "dir": {
          "type": "string",
          "description": "The directory from which to run the command from. If `dir` does not exist, then\n`Command` will fail."
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional environment variables available to the command's process."
        },
        "interpreter": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The program and arguments to run the command.\nOn Linux and macOS, defaults to: `[\"/bin/sh\", \"-c\"]`. On Windows, defaults to: `[\"cmd\", \"/C\"]`"
        },
        "logging": {
          "$ref": "#/types/command:local:Logging",
          "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
        },
        "stdin": {
          "type": "string",
          "description": "Pass a string to the command's process as standard in"
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger a resource replacement on changes to any of these values. The\ntrigger values can be of any type. If a value is different in the current update compared to the\nprevious update, the resource will be replaced, i.e., the \"create\" command will be re-run.\nPlease see the resource documentation for examples.",
          "replaceOnChanges": true
        },
        "update": {
          "type": "string",
          "description": "The command to run on update, if empty, create will \nrun again. The environment variables PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR \nare set to the stdout and stderr properties of the Command resource from previous \ncreate or update steps."
        }
      }
    },
    "command:remote:Command": {
      "description": "A command to run on a remote host. The connection is established via ssh.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Triggers\n\nThis example defines several trigger values of various kinds. Changes to any of them will cause `cmd` to be re-run.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as command from \"@pulumi/command\";\nimport * as random from \"@pulumi/random\";\n\nconst str = \"foo\";\nconst fileAsset = new pulumi.asset.FileAsset(\"Pulumi.yaml\");\nconst rand = new random.RandomString(\"rand\", {length: 5});\nconst localFile = new command.local.Command(\"localFile\", {\n    create: \"touch foo.txt\",\n    archivePaths: [\"*.txt\"],\n});\nconst cmd = new command.remote.Command(\"cmd\", {\n    connection: {\n        host: \"insert host here\",\n    },\n    create: \"echo create > op.txt\",\n    delete: \"echo delete >> op.txt\",\n    triggers: [\n        str,\n        rand.result,\n        fileAsset,\n        localFile.archive,\n    ],\n});\n\n```\n\n```python\nimport pulumi\nimport pulumi_command as command\nimport pulumi_random as random\n\nfoo = \"foo\"\nfile_asset_var = pulumi.FileAsset(\"Pulumi.yaml\")\nrand = random.RandomString(\"rand\", length=5)\nlocal_file = command.local.Command(\"localFile\",\n    create=\"touch foo.txt\",\n    archive_paths=[\"*.txt\"])\n\ncmd = command.remote.Command(\"cmd\",\n    connection=command.remote.ConnectionArgs(\n        host=\"insert host here\",\n    ),\n    create=\"echo create > op.txt\",\n    delete=\"echo delete >> op.txt\",\n    triggers=[\n        foo,\n        rand.result,\n        file_asset_var,\n        local_file.archive,\n    ])\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-command/sdk/go/command/local\"\n\t\"github.com/pulumi/pulumi-command/sdk/go/command/remote\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstr := pulumi.String(\"foo\")\n\n\t\tfileAsset := pulumi.NewFileAsset(\"Pulumi.yaml\")\n\n\t\trand, err := random.NewRandomString(ctx, \"rand\", &random.RandomStringArgs{\n\t\t\tLength: pulumi.Int(5),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlocalFile, err := local.NewCommand(ctx, \"localFile\", &local.CommandArgs{\n\t\t\tCreate: pulumi.String(\"touch foo.txt\"),\n\t\t\tArchivePaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*.txt\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = remote.NewCommand(ctx, \"cmd\", &remote.CommandArgs{\n\t\t\tConnection: &remote.ConnectionArgs{\n\t\t\t\tHost: pulumi.String(\"insert host here\"),\n\t\t\t},\n\t\t\tCreate: pulumi.String(\"echo create > op.txt\"),\n\t\t\tDelete: pulumi.String(\"echo delete >> op.txt\"),\n\t\t\tTriggers: pulumi.Array{\n\t\t\t\tstr,\n\t\t\t\trand.Result,\n\t\t\t\tfileAsset,\n\t\t\t\tlocalFile.Archive,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n```csharp\nusing Pulumi;\nusing Command = Pulumi.Command;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() => \n{\n    var str = \"foo\";\n\n    var fileAssetVar = new FileAsset(\"Pulumi.yaml\");\n\n    var rand = new Random.RandomString(\"rand\", new()\n    {\n        Length = 5,\n    });\n\n    var localFile = new Command.Local.Command(\"localFile\", new()\n    {\n        Create = \"touch foo.txt\",\n        ArchivePaths = new[]\n        {\n            \"*.txt\",\n        },\n    });\n\n    var cmd = new Command.Remote.Command(\"cmd\", new()\n    {\n        Connection = new Command.Remote.Inputs.ConnectionArgs\n        {\n            Host = \"insert host here\",\n        },\n        Create = \"echo create > op.txt\",\n        Delete = \"echo delete >> op.txt\",\n        Triggers = new object[]\n        {\n            str,\n            rand.Result,\n            fileAssetVar,\n            localFile.Archive,\n        },\n    });\n\n});\n```\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fileAssetVar = new FileAsset(\"Pulumi.yaml\");\n\n        var rand = new RandomString(\"rand\", RandomStringArgs.builder()\n            .length(5)\n            .build());\n\n        var localFile = new Command(\"localFile\", CommandArgs.builder()\n            .create(\"touch foo.txt\")\n            .archivePaths(\"*.txt\")\n            .build());\n\n        var cmd = new Command(\"cmd\", CommandArgs.builder()\n            .connection(ConnectionArgs.builder()\n                .host(\"insert host here\")\n                .build())\n            .create(\"echo create > op.txt\")\n            .delete(\"echo delete >> op.txt\")\n            .triggers(            \n                rand.result(),\n                fileAssetVar,\n                localFile.archive())\n            .build());\n\n    }\n}\n```\n\n```yaml\nconfig: {}\noutputs: {}\n\nresources:\n  rand:\n    type: random:index/randomString:RandomString\n    properties:\n      length: 5\n\n  localFile:\n    type: command:local:Command\n    properties:\n      create: touch foo.txt\n      archivePaths:\n        - \"*.txt\"\n\n  cmd:\n    type: command:remote:Command\n    properties:\n      connection:\n        host: \"insert host here\"\n      create: echo create > op.txt\n      delete: echo delete >> op.txt\n      triggers:\n        - ${rand.result}\n        - ${fileAsset}\n        - ${localFile.archive}\n\nvariables:\n  fileAsset:\n    fn::fileAsset: \"Pulumi.yaml\"\n```\n\n{{% /example %}}\n\n{{% /examples %}}",
      "properties": {
        "addPreviousOutputInEnv": {
          "type": "boolean",
          "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
          "default": true
        },
        "connection": {
          "$ref": "#/types/command:remote:Connection",
          "description": "The parameters with which to connect to the remote host.",
          "secret": true
        },
        "create": {
          "type": "string",
          "description": "The command to run on create."
        },
        "delete": {
          "type": "string",
          "description": "The command to run on delete. The environment variables PULUMI_COMMAND_STDOUT\nand PULUMI_COMMAND_STDERR are set to the stdout and stderr properties of the\nCommand resource from previous create or update steps."
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional environment variables available to the command's process.\nNote that this only works if the SSH server is configured to accept these variables via AcceptEnv.\nAlternatively, if a Bash-like shell runs the command on the remote host, you could prefix the command itself\nwith the variables in the form 'VAR=value command'."
        },
        "logging": {
          "$ref": "#/types/command:remote:Logging",
          "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
        },
        "stderr": {
          "type": "string",
          "description": "The standard error of the command's process"
        },
        "stdin": {
          "type": "string",
          "description": "Pass a string to the command's process as standard in"
        },
        "stdout": {
          "type": "string",
          "description": "The standard output of the command's process"
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger a resource replacement on changes to any of these values. The\ntrigger values can be of any type. If a value is different in the current update compared to the\nprevious update, the resource will be replaced, i.e., the \"create\" command will be re-run.\nPlease see the resource documentation for examples.",
          "replaceOnChanges": true
        },
        "update": {
          "type": "string",
          "description": "The command to run on update, if empty, create will \nrun again. The environment variables PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR \nare set to the stdout and stderr properties of the Command resource from previous \ncreate or update steps."
        }
      },
      "type": "object",
      "required": [
        "connection",
        "stderr",
        "stdout"
      ],
      "inputProperties": {
        "addPreviousOutputInEnv": {
          "type": "boolean",
          "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
          "default": true
        },
        "connection": {
          "$ref": "#/types/command:remote:Connection",
          "description": "The parameters with which to connect to the remote host.",
          "secret": true
        },
        "create": {
          "type": "string",
          "description": "The command to run on create."
        },
        "delete": {
          "type": "string",
          "description": "The command to run on delete. The environment variables PULUMI_COMMAND_STDOUT\nand PULUMI_COMMAND_STDERR are set to the stdout and stderr properties of the\nCommand resource from previous create or update steps."
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional environment variables available to the command's process.\nNote that this only works if the SSH server is configured to accept these variables via AcceptEnv.\nAlternatively, if a Bash-like shell runs the command on the remote host, you could prefix the command itself\nwith the variables in the form 'VAR=value command'."
        },
        "logging": {
          "$ref": "#/types/command:remote:Logging",
          "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
        },
        "stdin": {
          "type": "string",
          "description": "Pass a string to the command's process as standard in"
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger a resource replacement on changes to any of these values. The\ntrigger values can be of any type. If a value is different in the current update compared to the\nprevious update, the resource will be replaced, i.e., the \"create\" command will be re-run.\nPlease see the resource documentation for examples.",
          "replaceOnChanges": true
        },
        "update": {
          "type": "string",
          "description": "The command to run on update, if empty, create will \nrun again. The environment variables PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR \nare set to the stdout and stderr properties of the Command resource from previous \ncreate or update steps."
        }
      },
      "requiredInputs": [
        "connection"
      ]
    },
    "command:remote:CopyToRemote": {
      "description": "Copy an Asset or Archive to a remote host.",
      "properties": {
        "connection": {
          "$ref": "#/types/command:remote:Connection",
          "description": "The parameters with which to connect to the remote host.",
          "secret": true
        },
        "remotePath": {
          "type": "string",
          "description": "The destination path on the remote host. The last element of the path will be created if it doesn't exist but it's an error when additional elements don't exist. When the remote path is an existing directory, the source file or directory will be copied into that directory. When the source is a file and the remote path is an existing file, that file will be overwritten. When the source is a directory and the remote path an existing file, the copy will fail."
        },
        "source": {
          "$ref": "pulumi.json#/Asset",
          "description": "An [asset or an archive](https://www.pulumi.com/docs/concepts/assets-archives/) to upload as the source of the copy. It must be path-based, i.e., be a `FileAsset` or a `FileArchive`. The item will be copied as-is; archives like .tgz will not be unpacked. Directories are copied recursively, overwriting existing files."
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger replacements on changes to this input.",
          "replaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "connection",
        "remotePath",
        "source"
      ],
      "inputProperties": {
        "connection": {
          "$ref": "#/types/command:remote:Connection",
          "description": "The parameters with which to connect to the remote host.",
          "secret": true
        },
        "remotePath": {
          "type": "string",
          "description": "The destination path on the remote host. The last element of the path will be created if it doesn't exist but it's an error when additional elements don't exist. When the remote path is an existing directory, the source file or directory will be copied into that directory. When the source is a file and the remote path is an existing file, that file will be overwritten. When the source is a directory and the remote path an existing file, the copy will fail."
        },
        "source": {
          "$ref": "pulumi.json#/Asset",
          "description": "An [asset or an archive](https://www.pulumi.com/docs/concepts/assets-archives/) to upload as the source of the copy. It must be path-based, i.e., be a `FileAsset` or a `FileArchive`. The item will be copied as-is; archives like .tgz will not be unpacked. Directories are copied recursively, overwriting existing files."
        },
        "triggers": {
          "type": "array",
          "items": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "Trigger replacements on changes to this input.",
          "replaceOnChanges": true
        }
      },
      "requiredInputs": [
        "connection",
        "remotePath",
        "source"
      ]
    }
  },
  "functions": {
    "command:local:run": {
      "description": "A local command to be executed.\nThis command will always be run on any preview or deployment. Use `local.Command` to avoid duplicating executions.",
      "inputs": {
        "properties": {
          "addPreviousOutputInEnv": {
            "type": "boolean",
            "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
            "default": true
          },
          "archivePaths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of path globs to return as a single archive asset after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
          },
          "assetPaths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of path globs to read after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```"
          },
          "command": {
            "type": "string",
            "description": "The command to run."
          },
          "dir": {
            "type": "string",
            "description": "The directory from which to run the command from. If `dir` does not exist, then\n`Command` will fail."
          },
          "environment": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional environment variables available to the command's process."
          },
          "interpreter": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The program and arguments to run the command.\nOn Linux and macOS, defaults to: `[\"/bin/sh\", \"-c\"]`. On Windows, defaults to: `[\"cmd\", \"/C\"]`"
          },
          "logging": {
            "$ref": "#/types/command:local:Logging",
            "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
          },
          "stdin": {
            "type": "string",
            "description": "Pass a string to the command's process as standard in"
          }
        },
        "type": "object",
        "required": [
          "command"
        ]
      },
      "outputs": {
        "properties": {
          "addPreviousOutputInEnv": {
            "default": true,
            "description": "If the previous command's stdout and stderr (as generated by the prior create/update) is\ninjected into the environment of the next run as PULUMI_COMMAND_STDOUT and PULUMI_COMMAND_STDERR.\nDefaults to true.",
            "type": "boolean"
          },
          "archive": {
            "$ref": "pulumi.json#/Archive",
            "description": "An archive asset containing files found after running the command."
          },
          "archivePaths": {
            "description": "A list of path globs to return as a single archive asset after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "assetPaths": {
            "description": "A list of path globs to read after the command completes.\n\nWhen specifying glob patterns the following rules apply:\n- We only include files not directories for assets and archives.\n- Path separators are `/` on all platforms - including Windows.\n- Patterns starting with `!` are 'exclude' rules.\n- Rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- All returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- For full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### Example\n\nGiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nWhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nThe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "assets": {
            "additionalProperties": {
              "$ref": "pulumi.json#/Asset"
            },
            "description": "A map of assets found after running the command.\nThe key is the relative path from the command dir",
            "type": "object"
          },
          "command": {
            "description": "The command to run.",
            "type": "string"
          },
          "dir": {
            "description": "The directory from which to run the command from. If `dir` does not exist, then\n`Command` will fail.",
            "type": "string"
          },
          "environment": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional environment variables available to the command's process.",
            "type": "object"
          },
          "interpreter": {
            "description": "The program and arguments to run the command.\nOn Linux and macOS, defaults to: `[\"/bin/sh\", \"-c\"]`. On Windows, defaults to: `[\"cmd\", \"/C\"]`",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "logging": {
            "$ref": "#/types/command:local:Logging",
            "description": "If the command's stdout and stderr should be logged. This doesn't affect the capturing of\nstdout and stderr as outputs. If there might be secrets in the output, you can disable logging here and mark the\noutputs as secret via 'additionalSecretOutputs'. Defaults to logging both stdout and stderr."
          },
          "stderr": {
            "description": "The standard error of the command's process",
            "type": "string"
          },
          "stdin": {
            "description": "Pass a string to the command's process as standard in",
            "type": "string"
          },
          "stdout": {
            "description": "The standard output of the command's process",
            "type": "string"
          }
        },
        "required": [
          "command",
          "stderr",
          "stdout"
        ],
        "type": "object"
      }
    }
  }
}
